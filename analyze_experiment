analyze_exp <- function(namespace){
  require(data.table)
  
  #connect to Amazon Redshift
  driver <- RJDBC::JDBC("com.amazon.redshift.jdbc42.Driver", "RedshiftJDBC42-1.2.10.1009.jar", identifier.quote="`")
  url <- "jdbc:redshift://ds-redshift-psbx-dsa.cblrlw3ocr3v.us-west-2.redshift.amazonaws.com:5439/cust_analytics_prd?user=ck2r&password=tP011720180550_8192_CK2R"
  con <- RJDBC::dbConnect(driver, url)
  
  `%+%` <- function(a,b) paste0(a,b)
  
  sqlcode <- "select
  namespace, 
  cookie_id,
  session_id,
  session_date,
  platform,
  parameter_value,
  page_views,
  product_views,
  items_added,
  orders,
  items_sold,
  demand
  from bi_prd.experiment_data
  where multi_parameter_value_flag = 0
  and namespace = '" %+% namespace %+% "'"
  
  experiment_data <- sqlcode %>% RJDBC::dbGetQuery(conn = con)
  
  #close connection
  RJDBC::dbDisconnect(con)
  
  arms <- sort(unique(experiment_data$parameter_value))
  n_arms <- length(arms)
  
  if(n_arms < 2)
  {
    warning("Experiment ", namespace, " has less than two arms, skip!")
    return(data_frame())
  }
  
  ############### create the UDV level table from session level table  
  b <- data.table(experiment_data)
  UDV_table <- b[, lapply(.SD, sum), 
                 by = list(cookie_id, session_date, parameter_value), 
                 .SDcols = c("items_added", "orders", "product_views", "items_sold", "demand") 
                ] 
  
  UDV_table <- as.data.frame(UDV_table)
  
  ## add two extra columns for the binary ATB and PUR, and Product view rate
  setnames(UDV_table, 
           old = c('items_added', 'orders', 'product_views', 'items_sold', 'demand'), 
           new = c('abt_items', 'orders_sum', 'pdpviews', 'pur_items', 'pur_demand')
          )
  
  UDV_table$ATB <- UDV_table$abt_items
  UDV_table$PUR <- UDV_table$orders_sum
  UDV_table$PVR <- UDV_table$pdpviews
  
  ## convert items_sum (ATB) and orders_sum (PUR) to be 1 if they are > 0
  UDV_table$ATB[UDV_table$ATB != 0] <- 1
  UDV_table$PUR[UDV_table$PUR != 0] <- 1
  UDV_table$PVR[UDV_table$PVR != 0] <- 1
  
  ## convert it to data.table for later manipulations
  UDV_table <- as.data.table(UDV_table)
  
  ## more concise
  temp_UDV <- UDV_table[, length(cookie_id), by = parameter_value]
  colnames(temp_UDV) <- c("parameter_value", "UDV")
  temp_PVR_ATB_PUR <- UDV_table[, lapply(.SD, sum, na.rm = TRUE), by = parameter_value, .SDcols = c("PVR", "ATB", "PUR") ]
  temp_pdpviews_demand <- UDV_table[, lapply(.SD, mean, na.rm = TRUE), by = parameter_value, .SDcols = c("pdpviews", "pur_demand") ]
    
  res_groups <- merge(temp_UDV, temp_PVR_ATB_PUR, all.x = TRUE) %>%
                merge(., temp_pdpviews_demand, all.x = TRUE)
  
  ## result by group: 
  colnames(res_groups) = c("arm", "total_UDV", "total_PVR", "total_ATB", "total_pur", "average_pdpviews", "average_demand")
  #print(res_groups)
  
  ## test variances
  control_ind <- which(tolower(res_groups$arm) == 'default')
  test_ind <- which(tolower(res_groups$arm) != 'default')
  
  ## relative change of PVR, average_productviews, demand between each test(s) vs control
  RC_PVR <- lapply(test_ind, function(x) res_groups$total_PVR[x]/res_groups$total_PVR[control_ind] - 1)
  RC_pdpviews <- lapply(test_ind, function(x) res_groups$average_pdpviews[x]/res_groups$average_pdpviews[control_ind] - 1)
  RC_demand <- lapply(test_ind, function(x) res_groups$average_demand[x]/res_groups$average_demand[control_ind] - 1)
  
  ## relative change ABT between each test(s) vs control
  ATB_proptest <- lapply(test_ind, function(x) prop.test(
    c(res_groups$total_ATB[tolower(res_groups$arm) == 'default'], res_groups$total_ATB[x]), 
    c(res_groups$total_UDV[tolower(res_groups$arm) == 'default'], res_groups$total_UDV[x])))
  
  RC_ATB <- lapply(ATB_proptest, function(x) x$estimate[2]/x$estimate[1] - 1)
  
  ## relative change Ord between each test(s) vs control
  Ord_proptest <- lapply(test_ind, function(x) prop.test(
    c(res_groups$total_pur[tolower(res_groups$arm) == 'default'], res_groups$total_pur[x]), 
    c(res_groups$total_UDV[tolower(res_groups$arm) == 'default'], res_groups$total_UDV[x])))
  
  RC_Ord <- lapply(Ord_proptest, function(x) x$estimate[2]/x$estimate[1] - 1)
  
  relative_change_vec <- c(c(NA, unlist(RC_PVR)), c(NA, unlist(RC_pdpviews)), c(NA, unlist(RC_ATB)), c(NA, unlist(RC_Ord)), c(NA, unlist(RC_demand)))
  
  #### split the UDV_table based on parameter_value, then do statistical tests for pdpviews and pur_demand
  UDV_table_groups <- split(data.frame(UDV_table$pdpviews, UDV_table$pur_demand), UDV_table$parameter_value, drop = TRUE)
  
  pdpviews_utest <- lapply(test_ind, function(x) wilcox.test(UDV_table_groups[[control_ind]]$UDV_table.pdpviews, UDV_table_groups[[x]]$UDV_table.pdpviews, conf.level = 0.9))
  pur_demand_utest <- lapply(test_ind, function(x) wilcox.test(UDV_table_groups[[control_ind]]$UDV_table.pur_demand, UDV_table_groups[[x]]$UDV_table.pur_demand, conf.level = 0.9))
  
  PVR_proptest <- lapply(test_ind, function(x) prop.test(
    c(res_groups$total_PVR[tolower(res_groups$arm) == 'default'], res_groups$total_PVR[x]), 
    c(res_groups$total_UDV[tolower(res_groups$arm) == 'default'], res_groups$total_UDV[x])))
  
  # -------------- output block iterates... 
  # each block includes following rows: c("Product View Rate", "Product Views", "Add to Bag", "Order Conversion", "Demand")
  # with following columns: c("namespace", "parameter_value", "analysis_timestamp",	"experiment_name", "parameter_name", "outcome", "estimate",	"relative_change", "p_value", "significance", "n_analyzed")
  options(scipen = 5)
  KPI_metrics <- c("Product View Rate", "Product Views", "Add to Bag", "Order Conversion", "Demand")
  n_metrics <- length(KPI_metrics)
  parameter_value_vec <- rep(arms, times = n_metrics)
  outcome_vec <- rep(KPI_metrics, each = n_arms)
  
  estimate_PVR <- res_groups$total_PVR/res_groups$total_UDV
  estimate_pdpviews <- res_groups$average_pdpviews
  estimate_ATB <- res_groups$total_ATB/res_groups$total_UDV
  estimate_Ord <- res_groups$total_pur/res_groups$total_UDV
  estimate_demand <- res_groups$average_demand
  estimate_vec <- c(estimate_PVR, estimate_pdpviews, estimate_ATB, estimate_Ord, estimate_demand)
  
  pvalue_PVR <- unique(unlist(lapply(PVR_proptest, function(x) x$p.value)))
  pvalue_pdpviews <- unique(unlist(lapply(pdpviews_utest, function(x) x$p.value)))
  pvalue_ATB <- unique(unlist(lapply(ATB_proptest, function(x) x$p.value)))
  pvalue_Ord <- unique(unlist(lapply(Ord_proptest, function(x) x$p.value)))
  pvalue_demand <- unique(unlist(lapply(pur_demand_utest, function(x) x$p.value)))
  pvalue_vec <- c(c(NA, pvalue_PVR), c(NA, pvalue_pdpviews), c(NA, pvalue_ATB), c(NA, pvalue_Ord), c(NA, pvalue_demand))
  
  significance_vec <- rep(NA, length(pvalue_vec))
  for(j in 1:length(pvalue_vec))
  {
    if(is.na(pvalue_vec[j])){
      significance_vec[j] = NA
    } else if(pvalue_vec[j] <= 0.001) {
      significance_vec[j] = 'Statistically Significant***'
    } else if(pvalue_vec[j] <= 0.01) {
      significance_vec[j] = 'Statistically Significant**'
    } else if(pvalue_vec[j] <= 0.05) {
      significance_vec[j] = 'Statistically Significant*'
    } else if(pvalue_vec[j] <= 0.1) {
      significance_vec[j] = 'Statistically Significant'
    } else {
      significance_vec[j] = 'Not Statistically Significant'
    }
  }
  
  ## UDV numbers for each arm
  UDV_groups <- unlist(lapply(UDV_table_groups, nrow))
  UDV_vec <- rep(UDV_groups, times = n_metrics)
  
  namespace_vec <- rep(unique(experiment_data$namespace), times = n_arms*n_metrics)
  parameter_value_vec <- rep(arms, times = n_metrics)
  #analysis_timestamp <- Sys.time()
  analysis_timestamp <- format(Sys.time(), tz="America/Los_Angeles",usetz=TRUE)
  analysis_timestamp_vec <- rep(analysis_timestamp, times = n_arms*n_metrics)
  
  ## output the result block by block for different iterations 
  output <- data.frame(namespace_vec, analysis_timestamp_vec, parameter_value_vec, outcome_vec, estimate_vec, relative_change_vec, pvalue_vec, significance_vec, UDV_vec)
  colnames(output) = c("namespace", "analysis_timestamp", "parameter_value", "outcome", "estimate", "relative_change", "p_value", "significance", "n_UDV")
  
  return(output)
  
}
